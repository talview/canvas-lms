/*
 * Copyright (C) 2022 - present Instructure, Inc.
 *
 * This file is part of Canvas.
 *
 * Canvas is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3 of the License.
 *
 * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

import $ from 'jquery'
import 'jquery-migrate'
import {createGradebook} from './GradebookSpecHelper'
import MessageStudentsWhoHelper from '@canvas/grading/messageStudentsWhoHelper'
import * as FlashAlert from '@canvas/alerts/react/FlashAlert'
import fakeENV from '@canvas/test-utils/fakeENV'

QUnit.module('Gradebook Grading', () => {
  let gradebook

  QUnit.module('#isGradeEditable()', hooks => {
    hooks.beforeEach(() => {
      gradebook = createGradebook()
      gradebook.students = {1101: {id: '1101', isConcluded: false}}
      gradebook.assignments = {2301: {has_sub_assignments: false}}
      sinon
        .stub(gradebook.submissionStateMap, 'getSubmissionState')
        .returns({hideGrade: false, locked: false})
    })

    hooks.afterEach(() => {
      gradebook.submissionStateMap.getSubmissionState.restore()
    })

    test('returns true when the submission state is not locked', () => {
      strictEqual(gradebook.isGradeEditable('1101', '2301'), true)
    })

    test('returns false when the submission state is locked', () => {
      gradebook.submissionStateMap.getSubmissionState.returns({hideGrade: false, locked: true})
      strictEqual(gradebook.isGradeEditable('1101', '2301'), false)
    })

    test('returns false when the submission state is not defined', () => {
      gradebook.submissionStateMap.getSubmissionState.returns(undefined)
      strictEqual(gradebook.isGradeEditable('1101', '2301'), false)
    })

    test('uses the given assignment id when retrieving submission state', () => {
      gradebook.isGradeEditable('1101', '2301')
      const submission = gradebook.submissionStateMap.getSubmissionState.lastCall.args[0]
      strictEqual(submission.assignment_id, '2301')
    })

    test('uses the given student id when retrieving submission state', () => {
      gradebook.isGradeEditable('1101', '2301')
      const submission = gradebook.submissionStateMap.getSubmissionState.lastCall.args[0]
      strictEqual(submission.user_id, '1101')
    })

    test('returns false when the student enrollment is concluded', () => {
      gradebook.students[1101].isConcluded = true
      strictEqual(gradebook.isGradeEditable('1101', '2301'), false)
    })

    test('returns false when the student is not loaded', () => {
      delete gradebook.students[1101]
      strictEqual(gradebook.isGradeEditable('1101', '2301'), false)
    })

    test('returns false when the assignment has sub assignments', () => {
      sinon.stub(gradebook, 'getAssignment').returns({has_sub_assignments: true})
      strictEqual(gradebook.isGradeEditable('1101', '2301'), false)
    })
  })

  QUnit.module('#isGradeVisible()', hooks => {
    hooks.beforeEach(() => {
      gradebook = createGradebook()
      sinon
        .stub(gradebook.submissionStateMap, 'getSubmissionState')
        .returns({hideGrade: false, locked: true})
    })

    hooks.afterEach(() => {
      gradebook.submissionStateMap.getSubmissionState.restore()
    })

    test('returns true when the submission state is not hiding the grade', () => {
      strictEqual(gradebook.isGradeVisible('1101', '2301'), true)
    })

    test('returns false when the submission state is hiding the grade', () => {
      gradebook.submissionStateMap.getSubmissionState.returns({hideGrade: true, locked: true})
      strictEqual(gradebook.isGradeVisible('1101', '2301'), false)
    })

    test('returns false when the submission state is not defined', () => {
      gradebook.submissionStateMap.getSubmissionState.returns(undefined)
      strictEqual(gradebook.isGradeVisible('1101', '2301'), false)
    })

    test('uses the given assignment id when retrieving submission state', () => {
      gradebook.isGradeVisible('1101', '2301')
      const submission = gradebook.submissionStateMap.getSubmissionState.lastCall.args[0]
      strictEqual(submission.assignment_id, '2301')
    })

    test('uses the given student id when retrieving submission state', () => {
      gradebook.isGradeVisible('1101', '2301')
      const submission = gradebook.submissionStateMap.getSubmissionState.lastCall.args[0]
      strictEqual(submission.user_id, '1101')
    })
  })

  QUnit.module('#addPendingGradeInfo()', hooks => {
    let pendingGradeInfo
    let submission

    hooks.beforeEach(() => {
      gradebook = createGradebook()
      pendingGradeInfo = {enteredAs: 'points', excused: false, grade: 'A', score: 10, valid: true}
      submission = {assignmentId: '2301', userId: '1101'}
    })

    test('stores the pending grade info', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      deepEqual(gradebook.getPendingGradeInfo(submission), {
        ...pendingGradeInfo,
        assignmentId: '2301',
        userId: '1101',
      })
    })

    test('replaces existing pending grade info', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      gradebook.addPendingGradeInfo(submission, {...pendingGradeInfo, score: 9.9})
      strictEqual(gradebook.getPendingGradeInfo(submission).score, 9.9)
    })

    test('does not affect other submissions for the same assignment', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.getPendingGradeInfo({assignmentId: '2301', userId: '1102'}), null)
    })

    test('does not affect other submissions for the same user', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.getPendingGradeInfo({assignmentId: '2302', userId: '1101'}), null)
    })
  })

  QUnit.module('#getPendingGradeInfo()', hooks => {
    let pendingGradeInfo
    let submission

    hooks.beforeEach(() => {
      gradebook = createGradebook()
      pendingGradeInfo = {enteredAs: 'points', excused: false, grade: 'A', score: 10, valid: true}
      submission = {assignmentId: '2301', userId: '1101'}
    })

    test('returns null when the submission has no pending grade info', () => {
      strictEqual(gradebook.getPendingGradeInfo(submission), null)
    })

    test('does not match other submissions for the same assignment', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.getPendingGradeInfo({assignmentId: '2301', userId: '1102'}), null)
    })

    test('does not match other submissions for the same user', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.getPendingGradeInfo({assignmentId: '2302', userId: '1101'}), null)
    })
  })

  QUnit.module('#removePendingGradeInfo()', hooks => {
    let pendingGradeInfo
    let submission

    hooks.beforeEach(() => {
      gradebook = createGradebook()
      pendingGradeInfo = {enteredAs: 'points', excused: false, grade: 'A', score: 10, valid: true}
      submission = {assignmentId: '2301', userId: '1101'}
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
    })

    test('removes pending grade info for the submission', () => {
      gradebook.removePendingGradeInfo(submission)
      strictEqual(gradebook.getPendingGradeInfo(submission), null)
    })

    test('does not affect other submissions for the same assignment', () => {
      gradebook.addPendingGradeInfo({assignmentId: '2301', userId: '1102'}, pendingGradeInfo)
      gradebook.removePendingGradeInfo(submission)
      deepEqual(gradebook.getPendingGradeInfo({assignmentId: '2301', userId: '1102'}), {
        ...pendingGradeInfo,
        assignmentId: '2301',
        userId: '1102',
      })
    })

    test('does not affect other submissions for the same user', () => {
      gradebook.addPendingGradeInfo({assignmentId: '2302', userId: '1101'}, pendingGradeInfo)
      gradebook.removePendingGradeInfo(submission)
      deepEqual(gradebook.getPendingGradeInfo({assignmentId: '2302', userId: '1101'}), {
        ...pendingGradeInfo,
        assignmentId: '2302',
        userId: '1101',
      })
    })
  })

  QUnit.module('#submissionIsUpdating()', hooks => {
    let pendingGradeInfo
    let submission

    hooks.beforeEach(() => {
      gradebook = createGradebook()
      pendingGradeInfo = {enteredAs: null, excused: false, grade: null, score: null, valid: true}
      submission = {assignmentId: '2301', userId: '1101'}
    })

    test('returns true when the submission has valid pending grade info', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.submissionIsUpdating(submission), true)
    })

    test('returns false when the submission has invalid pending grade info', () => {
      Object.assign(pendingGradeInfo, {grade: 'invalid', valid: false})
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.submissionIsUpdating(submission), false)
    })

    test('returns false when the submission has no pending grade info', () => {
      strictEqual(gradebook.submissionIsUpdating(submission), false)
    })

    test('does not match other submissions for the same assignment', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.submissionIsUpdating({assignmentId: '2301', userId: '1102'}), false)
    })

    test('does not match other submissions for the same user', () => {
      gradebook.addPendingGradeInfo(submission, pendingGradeInfo)
      strictEqual(gradebook.submissionIsUpdating({assignmentId: '2302', userId: '1101'}), false)
    })
  })

  QUnit.module('#gradeSubmission()', hooks => {
    let apiPromise
    let submission
    let gradeInfo
    let response
    let renderSubmissionTrayStub

    hooks.beforeEach(() => {
      fakeENV.setup({
        GRADEBOOK_OPTIONS: {assignment_missing_shortcut: true},
      })
      const defaultGradingScheme = [
        ['A', 0.9],
        ['B', 0.8],
        ['C', 0.7],
        ['D', 0.6],
        ['E', 0.5],
      ]
      gradebook = createGradebook({default_grading_standard: defaultGradingScheme})
      gradebook.setAssignments({
        2301: {
          grading_type: 'letter_grade',
          id: '2301',
          name: 'Math Assignment',
          points_possible: 10,
          published: true,
        },
        2302: {
          grading_type: 'letter_grade',
          id: '2302',
          name: 'English Assignment',
          points_possible: 5,
          published: false,
        },
      })
      submission = {
        assignmentId: '2301',
        enteredScore: 9,
        enteredGrade: 'B',
        excused: false,
        id: '2501',
        userId: '1101',
      }
      gradeInfo = {enteredAs: 'points', excused: false, grade: 'A', score: 10, valid: true}
      response = {
        data: {score: 10},
      }
      sinon.stub(gradebook, 'apiUpdateSubmission').callsFake(() => {
        apiPromise = Promise.resolve(response)
        return apiPromise
      })
      sinon.stub($, 'flashWarning')
      renderSubmissionTrayStub = sinon.stub(gradebook, 'renderSubmissionTray')
    })

    hooks.afterEach(() => {
      $.flashWarning.restore()
      renderSubmissionTrayStub.restore()
      fakeENV.teardown()
    })

    test('updates the submission via Gradebook.apiUpdateSubmission', () => {
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        strictEqual(gradebook.apiUpdateSubmission.callCount, 1)
      })
    })

    test('sets "submission.excuse" to true when the submission is excused', () => {
      gradeInfo = {enteredAs: 'excused', excused: true, grade: null, score: null, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.excuse, true)
      })
    })

    test('sets "submission.late_policy_status" to "missing" when the submission is missing', () => {
      gradeInfo = {
        enteredAs: 'missing',
        late_policy_status: 'missing',
        excused: false,
        grade: null,
        score: null,
        valid: true,
      }
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.late_policy_status, 'missing')
      })
    })

    test('does not set "submission.excuse" when the submission is not excused', () => {
      gradeInfo.excused = false
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        notOk('excuse' in submissionData, 'does not set "excuse"')
      })
    })

    test('sets "submission.posted_grade" to the entered grade when the submission is not excused', () => {
      gradeInfo.excused = false
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        equal(submissionData.posted_grade, 10)
      })
    })

    test('does not set "submission.posted_grade" when the submission is excused', () => {
      gradeInfo = {enteredAs: 'excused', excused: true, grade: null, score: null, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        notOk('posted_grade' in submissionData, 'does not set "excuse"')
      })
    })

    test('uses the score from the grading data when the grade was entered as points', () => {
      gradeInfo = {enteredAs: 'points', excused: false, grade: '78%', score: 7.8, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.posted_grade, 7.8)
      })
    })

    test('uses the score from the grading data when the grade was entered as a percent', () => {
      gradeInfo = {enteredAs: 'percent', excused: false, grade: '78%', score: 7.8, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.posted_grade, 7.8)
      })
    })

    test('uses the grade from the grading data when the grade was entered as a grading scheme key', () => {
      gradeInfo = {enteredAs: 'gradingScheme', excused: false, grade: 'A', score: 7.8, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.posted_grade, 'A')
      })
    })

    test('uses the grade from the grading data when the grade was entered as a pass/fail key', () => {
      gradeInfo = {
        enteredAs: 'gradingScheme',
        excused: false,
        grade: 'complete',
        score: 10,
        valid: true,
      }
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.posted_grade, 'complete')
      })
    })

    test('uses an empty string "" when the grade is cleared', () => {
      gradeInfo = {enteredAs: null, excused: false, grade: null, score: null, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [submissionData] = gradebook.apiUpdateSubmission.firstCall.args
        strictEqual(submissionData.posted_grade, '')
      })
    })

    test('includes gradeInfo as the second parameter', () => {
      gradeInfo = {enteredAs: 'points', excused: false, grade: 'A', score: 9.5, valid: true}
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        const [, givenInfo] = gradebook.apiUpdateSubmission.firstCall.args
        deepEqual(givenInfo, gradeInfo)
      })
    })

    test('warns about unusually high grades', () => {
      response.data.score = 15
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        strictEqual($.flashWarning.callCount, 1)
      })
    })

    test('does not warn about slightly high grades', () => {
      response.data.score = 14.99
      gradebook.gradeSubmission(submission, gradeInfo)
      return apiPromise.then(() => {
        strictEqual($.flashWarning.callCount, 0)
      })
    })

    test('does not warn about the given grade when the update fails', () => {
      gradeInfo.grade = '1000'
      apiPromise = Promise.reject(new Error('FAIL'))
      gradebook.apiUpdateSubmission.returns(apiPromise)
      return gradebook.gradeSubmission(submission, gradeInfo).catch(() => {
        strictEqual($.flashWarning.callCount, 0)
      })
    })

    QUnit.module('when the grade is unchanged', contextHooks => {
      contextHooks.beforeEach(() => {
        const invalidGradeInfo = {
          enteredAs: null,
          excused: false,
          grade: 'invalid',
          score: null,
          valid: false,
        }
        gradebook.addPendingGradeInfo(submission, invalidGradeInfo)
        Object.assign(gradeInfo, {enteredAs: 'points', grade: 'B', score: 9})
      })

      test('removes an existing pending grade info for the submission', () => {
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.getPendingGradeInfo(submission), null)
      })

      test('does not update the grade via the api', () => {
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.apiUpdateSubmission.callCount, 0)
      })

      test('updates cells in the student row', () => {
        sinon.stub(gradebook, 'updateRowCellsForStudentIds')
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.updateRowCellsForStudentIds.callCount, 1)
      })

      test('uses the id of the student when updating the row cells', () => {
        sinon.stub(gradebook, 'updateRowCellsForStudentIds')
        gradebook.gradeSubmission(submission, gradeInfo)
        const [userIds] = gradebook.updateRowCellsForStudentIds.lastCall.args
        deepEqual(userIds, ['1101'])
      })

      test('re-renders the submission tray if it is open', () => {
        sinon.stub(gradebook, 'getSubmissionTrayState').callsFake(() => ({open: true}))

        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.renderSubmissionTray.callCount, 1)

        gradebook.getSubmissionTrayState.restore()
      })

      test('does not attempt to re-render the submission tray if it is not open', () => {
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.renderSubmissionTray.callCount, 0)
      })
    })

    QUnit.module('when the grade info is invalid', contextHooks => {
      contextHooks.beforeEach(() => {
        gradeInfo = {
          enteredAs: null,
          excused: false,
          grade: 'invalid',
          score: null,
          valid: false,
        }
        // return to ensure that any changes cause the hook to wait for the
        // potential promise from the api
        sinon.stub(FlashAlert, 'showFlashAlert')
        return gradebook.gradeSubmission(submission, gradeInfo)
      })

      contextHooks.afterEach(() => {
        FlashAlert.showFlashAlert.restore()
      })

      test('adds the pending grade info for the submission', () => {
        deepEqual(gradebook.getPendingGradeInfo({assignmentId: '2301', userId: '1101'}), {
          ...gradeInfo,
          assignmentId: '2301',
          userId: '1101',
        })
      })

      test('does not update the grade via the api', () => {
        strictEqual(gradebook.apiUpdateSubmission.callCount, 0)
      })

      test('shows a flash alert', () => {
        strictEqual(FlashAlert.showFlashAlert.callCount, 1)
      })

      test('uses the "error" type for the flash alert', () => {
        const [{type}] = FlashAlert.showFlashAlert.lastCall.args
        equal(type, 'error')
      })

      test('mentions the invalid grade in the flash alert', () => {
        const [{message}] = FlashAlert.showFlashAlert.lastCall.args
        ok(message.includes('invalid grade'))
      })

      test('updates cells in the student row', () => {
        sinon.stub(gradebook, 'updateRowCellsForStudentIds')
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.updateRowCellsForStudentIds.callCount, 1)
      })

      test('uses the id of the student when updating the row cells', () => {
        sinon.stub(gradebook, 'updateRowCellsForStudentIds')
        gradebook.gradeSubmission(submission, gradeInfo)
        const [userIds] = gradebook.updateRowCellsForStudentIds.lastCall.args
        deepEqual(userIds, ['1101'])
      })

      test('re-renders the submission tray if it is open', () => {
        sinon.stub(gradebook, 'getSubmissionTrayState').callsFake(() => ({open: true}))
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.renderSubmissionTray.callCount, 1)
        gradebook.getSubmissionTrayState.restore()
      })

      test('does not attempt to re-render the submission tray if it is not open', () => {
        gradebook.gradeSubmission(submission, gradeInfo)
        strictEqual(gradebook.renderSubmissionTray.callCount, 0)
      })
    })
  })
})

QUnit.module('Gradebook#toggleViewUngradedAsZero', hooks => {
  let gradebook

  hooks.beforeEach(() => {
    gradebook = createGradebook({
      grid: {
        getColumns: () => [],
        updateCell: sinon.stub(),
      },
      settings: {
        allow_view_ungraded_as_zero: 'true',
      },
    })

    sandbox.stub(gradebook, 'saveSettings').callsFake(() => Promise.resolve())
  })

  test('toggles viewUngradedAsZero to true when false', () => {
    gradebook.gridDisplaySettings.viewUngradedAsZero = false
    sandbox.stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')
    gradebook.toggleViewUngradedAsZero()

    strictEqual(gradebook.gridDisplaySettings.viewUngradedAsZero, true)
  })

  test('toggles viewUngradedAsZero to false when true', () => {
    gradebook.gridDisplaySettings.viewUngradedAsZero = true
    sandbox.stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')
    gradebook.toggleViewUngradedAsZero()

    strictEqual(gradebook.gridDisplaySettings.viewUngradedAsZero, false)
  })

  test('calls updateColumnsAndRenderViewOptionsMenu after toggling', () => {
    gradebook.gridDisplaySettings.viewUngradedAsZero = true
    const stubFn = sandbox
      .stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')
      .callsFake(() => {
        strictEqual(gradebook.gridDisplaySettings.viewUngradedAsZero, false)
      })
    gradebook.toggleViewUngradedAsZero()

    strictEqual(stubFn.callCount, 1)
  })

  test('calls saveSettings with the new value of the setting', () => {
    gradebook.gridDisplaySettings.viewUngradedAsZero = false
    sandbox.stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')

    gradebook.toggleViewUngradedAsZero()

    deepEqual(gradebook.saveSettings.firstCall.args[0], {
      viewUngradedAsZero: true,
    })
  })

  test('calls calculateStudentGrade once for each student', () => {
    const allStudents = [
      {id: '1101', assignment_201: {}, assignment_202: {}},
      {id: '1102', assignment_201: {}},
    ]
    sandbox.stub(gradebook.courseContent.students, 'listStudents').returns(allStudents)

    sandbox.stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')
    sandbox.stub(gradebook, 'calculateStudentGrade')
    gradebook.toggleViewUngradedAsZero()

    strictEqual(gradebook.calculateStudentGrade.callCount, 2)
  })

  test('calls updateAllTotalColumns', () => {
    gradebook.students = {
      1101: {id: '1101', assignment_201: {}, assignment_202: {}},
      1102: {id: '1102', assignment_201: {}},
    }

    sandbox.stub(gradebook, 'updateColumnsAndRenderViewOptionsMenu')
    sandbox.stub(gradebook, 'updateAllTotalColumns')
    gradebook.toggleViewUngradedAsZero()

    strictEqual(gradebook.updateAllTotalColumns.callCount, 1)
  })
})

QUnit.module('Gradebook#sendMessageStudentsWho', hooks => {
  let gradebook
  let apiRequestStub

  const recipientsIds = [1, 2, 3, 4]
  const subject = 'subject'
  const body = 'body'

  hooks.beforeEach(() => {
    gradebook = createGradebook({
      context_id: '1234',
      show_message_students_with_observers_dialog: true,
    })

    gradebook.gridData.rows = [
      {id: '3', sortable_name: 'Z'},
      {id: '4', sortable_name: 'A'},
      {id: '1', sortable_name: 'C'},
    ]

    gradebook.gridData.columns.scrollable = [
      'assignment_3',
      'custom_col_8',
      'assignment_2',
      'assignment_group_1',
      'assignment_7',
      'total_grade',
    ]

    const assignments = [
      {id: '3', assignment_group_id: '10'},
      {id: '2', assignment_group_id: '10'},
      {id: '7'},
    ]
    gradebook.gotAllAssignmentGroups([{id: '10', position: 1, name: 'Assignments', assignments}])

    sandbox.stub(FlashAlert, 'showFlashSuccess')
    sandbox.stub(FlashAlert, 'showFlashError')

    apiRequestStub = sinon.stub(MessageStudentsWhoHelper, 'sendMessageStudentsWho').resolves()
  })

  hooks.afterEach(() => {
    apiRequestStub.restore()
    FlashAlert.showFlashSuccess.restore()
    FlashAlert.showFlashError.restore()
  })

  test('sends the messages via Gradebook.sendMessageStudentsWho', async () => {
    await gradebook.sendMessageStudentsWho({
      recipientsIds,
      subject,
      body,
    })

    strictEqual(apiRequestStub.callCount, 1)
  })

  test('includes recipientsIds as the first parameter', async () => {
    await gradebook.sendMessageStudentsWho({
      recipientsIds,
      subject,
      body,
    })

    strictEqual(apiRequestStub.firstCall.args[0], recipientsIds)
  })

  test('includes subject as the second parameter', async () => {
    await gradebook.sendMessageStudentsWho({
      recipientsIds,
      subject,
      body,
    })

    strictEqual(apiRequestStub.firstCall.args[1], subject)
  })

  test('includes body as the third parameter', async () => {
    await gradebook.sendMessageStudentsWho({
      recipientsIds,
      subject,
      body,
    })

    strictEqual(apiRequestStub.firstCall.args[2], body)
  })

  test('if provided, includes mediaFile as the fifth parameter', async () => {
    const mediaFile = {id: '1959', type: 'video'}
    await gradebook.sendMessageStudentsWho({
      body,
      mediaFile,
      recipientsIds,
      subject,
    })

    deepEqual(apiRequestStub.firstCall.args[4], mediaFile)
  })

  test('if provided, includes attachmentIds as the sixth parameter', async () => {
    const attachmentIds = ['4', '82']
    await gradebook.sendMessageStudentsWho({
      attachmentIds,
      body,
      recipientsIds,
      subject,
    })

    deepEqual(apiRequestStub.firstCall.args[5], attachmentIds)
  })

  test('shows a success flash alert when the process succeeds', async () => {
    const message = 'Message sent successfully'
    await gradebook.sendMessageStudentsWho({
      recipientsIds,
      subject,
      body,
    })
    strictEqual(FlashAlert.showFlashSuccess.firstCall.args[0], message)
  })

  test('shows an error flash alert when the process fails', async () => {
    let errorThrown = false
    apiRequestStub.rejects(new Error(':-/'))
    try {
      await gradebook.sendMessageStudentsWho({
        recipientsIds,
        subject,
        body,
      })
    } catch (_error) {
      errorThrown = true
    }
    strictEqual(errorThrown, true)
    strictEqual(FlashAlert.showFlashError.callCount, 1)
  })
})
